package homebridgeconfig

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"strconv"
	"strings"

	"github.com/conthing/export-homebridge/errors"
	"github.com/conthing/utils/common"
)

//AutoGenerated means the construction of config.json，前4个定义的结构体是生成config.json文件用的
type AutoGenerated struct {
	Description string       `json:"description"`
	Bridge      BridgeStruct `json:"bridge"`
	Platforms   []Platform   `json:"platforms"`
}
type BridgeStruct struct {
	Serialnumber string `json:"serialNumber"`
	Pin          string `json:"pin"`
	Port         int    `json:"port"`
	Name         string `json:"name"`
	Model        string `json:"model"`
	Manufacturer string `json:"manufacturer"`
	Username     string `json:"username"`
	Repport      string `json:"repport"`
}
type Platform struct {
	Accessories []Accessary `json:"accessories"`
	Name        string      `json:"name"`
	ConfigPath  string      `json:"configPath"`
	Platform    string      `json:"platform"`
}

//omitempty的注释:1、加上omitempty如果dimmerable为nil，则生成的dimmerable不会显示""；2、不加omitempty则如果dimmerable为nil，生成的dimmerable会显示""；
type Accessary struct {
	Service    string `json:"service"`
	Name       string `json:"name"`
	ProxyID    string `json:"proxy_id"`
	Accessory  string `json:"accessory"`
	Dimmerable string `json:"dimmerable,omitempty"`
	Modes      string `json:"modes,omitempty"`
	Fanlevels  string `json:"fanlevels,omitempty"`
}

//Envelope means the data transformed from coredata
type Envelope []struct {
	Name    string
	ID      string
	Profile Profile
}
type Profile struct {
	Name     string
	Commands []Commands
}

//Command means control
type Commands struct {
	ID   string
	Name string
}
type Accessarysender struct {
	Service  string
	Name     string
	ID       string
	Commands []Commands
}

type Response struct {
	Cached bool            `json:"cached"`
	Data   []VirtualDevice `json:"data"`
}

var Pincode string
var Accessaries []Accessary
var Accessarysenders []Accessarysender

func changeNameUponConflict(tempAccessaries []Accessary, oldname string) (name string) {
	name = oldname
	if tempAccessaries != nil {
		index := 1
		for i := 0; i < len(tempAccessaries); i++ { //去遍历Accessaries里面有没有Name重复的
			access := tempAccessaries[i]
			if access.Name == name { //如果有重复
				name = fmt.Sprintf("%s(%d)", oldname, index) //在后面加(1)
				index++
				i = 0 // name 的index加1后，重新从i=0再遍历一遍有没有重复
			}
		}
	}
	return
}

/*定义GenerateHomebridgeConfig 函数，这个函数主要做:生成homebridge的config.json文件；执行这一步包括以下内容:1、zigbee设备的
name相同时则对应的虚拟设备的alias就会相同，这个函数就保证了homekit上的虚拟设备的alias没有重名的，相同alias的会在其后加((1)、
(2)、(3)....等等表示)，就是下方的的index := 1；2、homekit上的虚拟设备如果是调光灯在控制的时候就显示百分百，如果是开关灯在控制
的时候就显示开和关；3、指定homebridge的config.json文件的生成路径；*/
func GenerateHomebridgeConfig(light, curtain, hvac []byte, statusport string) error {
	var tempAccessaries []Accessary
	var tempAccessarysenders []Accessarysender
	var accessarysender Accessarysender //定义accessarysender变量，类型为Accessarysendervar

	var lightResponse Response
	var lightaccessary Accessary
	err := json.Unmarshal(light, &lightResponse) //对light设备进行json非序列化动作，有err返回err
	if err != nil {
		common.Log.Errorf("GenerateHomebridgeConfig(lightdevice, curtaindevice, hvacdevice []byte, statusport string) lightdevice json.Unmarshal(lightdevice, &projects) failed: %v", err)
	}
	if !lightResponse.Cached {
		common.Log.Error("ha-project 初始化未完成")
		return errors.ProjectUnfinishedErr
	}
	for _, virtualDevice := range lightResponse.Data { //定义project遍历52030中的light列表
		lightaccessary.ProxyID = virtualDevice.Id //将虚拟设备的Id赋值给accessary.ProxyID，注Id是从edgex分配来的
		lightaccessary.Accessory = "Control4"     //对accessary.Service、accessary.Accessory进行字符串赋值，以上这些都是config.json文件中的
		lightaccessary.Service = "Lightbulb"
		commands := accessarysender.Commands
		valid := true
		for _, projectcommand := range virtualDevice.Commands {
			if projectcommand.Value == "" && projectcommand.Name == "alias" {
				valid = false
				break
			}
		}
		if !valid {
			common.Log.Info("过滤该虚拟设备")
			continue
		}
		//这个for循环用在web上的zigbee设备的name如果相同则对应的虚拟设备灯光的alias也相同，这是在后面加上(1、2、3....)以示区分
		for _, projectcommand := range virtualDevice.Commands {
			if projectcommand.Name == "alias" { //若projectcommand.Name等于alias则去遍历从52030获取的所有light的ailas，看是否有相同的
				lightaccessary.Name = changeNameUponConflict(tempAccessaries, projectcommand.Value)
			} else if projectcommand.Name == "dimmerable" { //如果projectcommand.Name == "dimmerable"，则直接赋值accessary.Dimmerable = projectcommand.Value，
				lightaccessary.Dimmerable = projectcommand.Value // 注config.json中accessaries中只有proxy_id、name、dimmerable是需要从52030获取的，其它都是edgex分配的
			}
			var command Commands
			command.ID = projectcommand.Id
			command.Name = projectcommand.Name
			commands = append(commands, command)
		}
		accessarysender.Commands = commands
		accessarysender.Name = virtualDevice.Name
		accessarysender.ID = virtualDevice.Id
		tempAccessaries = append(tempAccessaries, lightaccessary)
		tempAccessarysenders = append(tempAccessarysenders, accessarysender) //store deviceid and commandid
	}

	common.Log.Info("lightAccessars: ", tempAccessaries) //store deviceid and commandid

	var curtainResponse Response
	var curtainaccessary Accessary
	err = json.Unmarshal(curtain, &curtainResponse)
	if !curtainResponse.Cached {
		common.Log.Error("ha-project 初始化未完成")
		return errors.ProjectUnfinishedErr
	}
	if err != nil {
		common.Log.Errorf("GenerateHomebridgeConfig(lightdevice, curtaindevice, hvacdevice []byte, statusport string) curtaindevice json.Unmarshal(curtaindevice, &projects) failed: %v", err)
	}
	for _, project := range curtainResponse.Data {
		curtainaccessary.ProxyID = project.Id
		curtainaccessary.Accessory = "Control4"
		curtainaccessary.Service = "WindowCovering"
		commands := accessarysender.Commands
		valid := true
		for _, projectcommand := range project.Commands {
			if projectcommand.Value == "" && projectcommand.Name == "alias" {
				valid = false
				break
			}
		}
		if valid == false {
			continue
		}
		for _, projectcommand := range project.Commands {
			if projectcommand.Name == "alias" {
				curtainaccessary.Name = changeNameUponConflict(tempAccessaries, projectcommand.Value)
			}
			var command Commands
			command.ID = projectcommand.Id
			command.Name = projectcommand.Name
			commands = append(commands, command)
		}
		accessarysender.Commands = commands
		accessarysender.Name = project.Name
		accessarysender.ID = project.Id
		tempAccessaries = append(tempAccessaries, curtainaccessary)
		tempAccessarysenders = append(tempAccessarysenders, accessarysender) //store deviceid and commandid
	}
	common.Log.Info("curtainAccessars: ", tempAccessaries) //store deviceid and commandid

	var hvacResponse Response
	var hvacaccessary Accessary
	err = json.Unmarshal(hvac, &hvacResponse)
	if !hvacResponse.Cached {
		common.Log.Error("ha-project 初始化未完成")
		return errors.ProjectUnfinishedErr
	}
	if err != nil {
		common.Log.Errorf("GenerateHomebridgeConfig(lightdevice, curtaindevice, hvacdevice []byte, statusport string) hvacdevice json.Unmarshal(hvacdevice, &projects) failed: %v", err)
	}
	for _, project := range hvacResponse.Data {
		hvacaccessary.ProxyID = project.Id
		hvacaccessary.Accessory = "Control4"
		hvacaccessary.Service = "Thermostat"
		commands := accessarysender.Commands
		valid := true
		for _, projectcommand := range project.Commands {
			if projectcommand.Value == "" && projectcommand.Name == "alias" {
				valid = false
				break
			}
		}
		if valid == false {
			continue
		}
		for _, projectcommand := range project.Commands {
			if projectcommand.Name == "alias" {
				hvacaccessary.Name = changeNameUponConflict(tempAccessaries, projectcommand.Value)
			} else if projectcommand.Name == "modes" {
				hvacaccessary.Modes = projectcommand.Value
			} else if projectcommand.Name == "fanlevels" {
				hvacaccessary.Fanlevels = projectcommand.Value
			}
			var command Commands
			command.ID = projectcommand.Id
			command.Name = projectcommand.Name
			commands = append(commands, command)
		}
		accessarysender.Commands = commands
		accessarysender.Name = project.Name
		accessarysender.ID = project.Id
		tempAccessaries = append(tempAccessaries, hvacaccessary)
		tempAccessarysenders = append(tempAccessarysenders, accessarysender)
		common.Log.Info("hvacAccessars: ", tempAccessaries) //store deviceid and commandid
	}

	configdata, err := createConfigData(tempAccessaries, statusport)
	if err != nil {
		common.Log.Errorf("createConfigData failed: %v", err)
	}
	b, err := json.MarshalIndent(configdata, "", " ")
	common.Log.Info(b)
	if err != nil {
		common.Log.Errorf("b, err := json.MarshalIndent(configdata) failed: %v", err)
	}
	//生成config.json文件的路径
	err = ioutil.WriteFile("/root/.homebridge/config.json", b, os.ModePerm) //create config.json
	if err != nil {
		common.Log.Errorf("ioutil.WriteFile(/root/.homebridge/config.json, b, os.ModePerm) failed: %v", err)
	}
	Accessaries = tempAccessaries
	Accessarysenders = tempAccessarysenders
	return nil
}

//creatConfigData()函数主要是:解释config.json文件中的各个参数，其中一些是常量赋值，一些是生成的
func createConfigData(accessaries []Accessary, statusport string) (configdata AutoGenerated, err error) {
	macAddr := common.GetMacAddrByName("eth0") //获取本机有线网卡的mac地址，注:一般来说，ubuntu系统中有线网卡的name是eth0，无线网卡的name是wlan0,但具体有线网卡和无线网卡的名字是什么还要看实际的板子
	mac := strings.ToUpper(macAddr)            //将获取到的mac地址的英文字母由小写变成大写
	pinstring := strings.Split(mac, ":")       //分割mac地址中的:和在一起的两个16进制的两位字符，举个例子:A1:22:3C:34:45:AB，在这里就是把A1和:完全分开，其它依此类推
	pinnum := make([]int, 6)
	if len(pinstring) == 6 { //由于上述已经分开了mac地址的:和由英文字母或数字组成的连在一起的两个字符，而每个字符都是16进制，故总共有6个字节
		for i, pin := range pinstring {
			n, err := strconv.ParseUint(pin, 16, 8)
			if err != nil {
				common.Log.Errorf("createConfigData(accessaries []Accessary, statusport string) n, err := strconv.ParseUint(pin, 16, 8) failed: %v", err)
				return configdata, err
			} else {
				pinnum[i] = int(n)
			}
		}
	} else {
		return
	}
	//获取本机的mac地址要反过来写的原因是如果正着写则第2次就homebridge页面就生成不了二维码和pin码了
	username := fmt.Sprintf("%02X:%02X:%02X:%02X:%02X:%02X", pinnum[5], pinnum[4], pinnum[3], pinnum[2], pinnum[1], pinnum[0])
	Pincode = fmt.Sprintf("%03d-%02d-%03d", pinnum[5]%90+10, pinnum[4]%90+10, pinnum[3]+100)
	sernum := fmt.Sprintf("%02d.%02d.%02d.%02d", pinnum[3]%100, pinnum[2]%100, pinnum[1]%100, pinnum[0]%100)
	configdata = AutoGenerated{
		Description: "This is an inSona plugin configuration file",
		Bridge: BridgeStruct{
			Serialnumber: sernum,
			Pin:          Pincode,
			Port:         51826,
			Name:         "homebridge-0",
			Model:        "homebridge-inSona",
			Manufacturer: "inSona",
			Username:     username,
			Repport:      statusport,
		},
		Platforms: []Platform{
			{
				Accessories: accessaries,
				Name:        "Control4",
				ConfigPath:  "/root/.homebridge/config.json",
				Platform:    "Control4",
			},
		},
	}
	return
}
