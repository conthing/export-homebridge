package device

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"math/rand"
	"os"
	"strconv"
	"time"
)

//AutoGenerated means the construction of config.json
type AutoGenerated struct {
	Description string       `json:"description"`
	Bridge      BridgeStruct `json:"bridge"`
	Platforms   []Platform   `json:"platforms"`
}

type BridgeStruct struct {
	Serialnumber string `json:"serialNumber"`
	Pin          string `json:"pin"`
	Port         int    `json:"port"`
	Name         string `json:"name"`
	Model        string `json:"model"`
	Manufacturer string `json:"manufacturer"`
	Username     string `json:"username"`
	Repport      string `json:"repport"`
}

type Platform struct {
	Accessories []Accessary `json:"accessories"`
	Name        string      `json:"name"`
	ConfigPath  string      `json:"configPath"`
	Platform    string      `json:"platform"`
}

type Accessary struct {
	Service   string `json:"service"`
	Name      string `json:"name"`
	ProxyID   string `json:"proxy_id"`
	Accessory string `json:"accessory"`
}

//Envelope means the data transformed from coredata
type Envelope []struct {
	Name    string
	ID      string
	Labels  []string
	Profile Profile
}

type Profile struct {
	Commands []Commands
}

//Command means control
type Commands struct {
	ID   string
	Name string
}

type Accessarysender struct {
	Service  string
	Name     string
	ID       string
	Commands []Commands
}

var Accessaries []Accessary
var Accessarysenders []Accessarysender
var Pinbuffer bytes.Buffer

func Decode(jsonStr []byte) {
	var env Envelope

	err := json.Unmarshal([]byte(jsonStr), &env)
	if err != nil {
		log.Fatal(err)
	}
	// for the love of Gopher DO NOT DO THIS
	for i := range env {
		item := env[i]

		var accessary Accessary
		var accessarysender Accessarysender

		accessary.Name = item.Name
		accessary.ProxyID = item.ID
		accessary.Accessory = "Control4"
		accessary.Service = typeChoose(item.Labels[0])
		Accessaries = append(Accessaries, accessary)

		accessarysender.Name = item.Name
		accessarysender.ID = item.ID
		accessarysender.Service = typeChoose(item.Labels[0])
		command := accessarysender.Commands
		for i := 0; i < len(item.Profile.Commands); i++ {
			command = append(command, item.Profile.Commands[i])
		}
		accessarysender.Commands = command
		Accessarysenders = append(Accessarysenders, accessarysender) //store deviceid and commandid

	}
	configdata := createConfigData(Accessaries)
	b, _ := json.MarshalIndent(configdata, "", " ") //变成json字符串

	err = ioutil.WriteFile("/root/.homebridge/config.json", b, os.ModeAppend) //create config.json
	if err != nil {
		fmt.Println(err)
	}

	fmt.Println(string(b))
	return
}

func typeChoose(oldtype string) string {
	var newtype string
	switch oldtype {
	case "Light":
		newtype = "Lightbulb"
	default:
		fmt.Println("unsupportType")
		return oldtype
	}

	return newtype
}

func createConfigData(accessaries []Accessary) AutoGenerated {
	rand.Seed(time.Now().UnixNano())
	Pinbuffer.WriteString("0" + strconv.Itoa(rand.Intn(90)+10))
	Pinbuffer.WriteString("-" + strconv.Itoa(rand.Intn(90)+10))
	Pinbuffer.WriteString("-" + strconv.Itoa(rand.Intn(900)+100))
	fmt.Println(Pinbuffer.String())
	var sernum bytes.Buffer
	sernum.WriteString(strconv.Itoa(rand.Intn(100)))
	sernum.WriteString("." + strconv.Itoa(rand.Intn(100)))
	sernum.WriteString("." + strconv.Itoa(rand.Intn(100)))
	sernum.WriteString("." + strconv.Itoa(rand.Intn(100)))
	fmt.Println(sernum.String())
	configdata := AutoGenerated{
		Description: "This is an inSona plugin configuration file",
		Bridge: BridgeStruct{
			Serialnumber: sernum.String(),
			Pin:          Pinbuffer.String(),
			Port:         51826,
			Name:         "homebridge-0",
			Model:        "homebridge-inSona",
			Manufacturer: "inSona",
			Username:     "CC:22:3D:E3:CE:30",
			Repport:      "tcp://127.0.0.1:10007",
		},
		Platforms: []Platform{
			Platform{
				Accessories: accessaries,
				Name:        "Control4",
				ConfigPath:  "/root/.homebridge/config.json",
				Platform:    "Control4",
			},
		},
	}
	return configdata
}

//serialnumber,pin,username create auto
