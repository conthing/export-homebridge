package device

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"strconv"
	"strings"

	"github.com/conthing/export-homebridge/pkg/errorHandle"
	"github.com/conthing/utils/common"
)

//AutoGenerated means the construction of config.json
//前4个定义的结构体是生成config.json文件用的
type AutoGenerated struct {
	Description string       `json:"description"`
	Bridge      BridgeStruct `json:"bridge"`
	Platforms   []Platform   `json:"platforms"`
}

type BridgeStruct struct {
	Serialnumber string `json:"serialNumber"`
	Pin          string `json:"pin"`
	Port         int    `json:"port"`
	Name         string `json:"name"`
	Model        string `json:"model"`
	Manufacturer string `json:"manufacturer"`
	Username     string `json:"username"`
	Repport      string `json:"repport"`
}

type Platform struct {
	Accessories []Accessary `json:"accessories"`
	Name        string      `json:"name"`
	ConfigPath  string      `json:"configPath"`
	Platform    string      `json:"platform"`
}

type Accessary struct {
	Service   string `json:"service"`
	Name      string `json:"name"`
	ProxyID   string `json:"proxy_id"`
	Accessory string `json:"accessory"`
	Dimmerable string  `json:"dimmerable,omitempty"`
}

//Envelope means the data transformed from coredata
//后4个定义的结构体是coredata转化来的   具体用在控制上
type Envelope []struct {
	Name    string
	ID      string
	Profile Profile
}

type Profile struct {
	Name     string
	Commands []Commands
}

//Command means control
type Commands struct {
	ID   string
	Name string
}

type Accessarysender struct {
	Service  string
	Name     string
	ID       string
	Commands []Commands
}

var Accessaries []Accessary
var Accessarysenders []Accessarysender
var Pincode string
////todo 函数体中缺乏注释，原则是代码不能自解释，就要加注释
//定义译码Decode函数，这个函数主要做:1、
func Decode(jsonStr []byte, label string, statusport string) error {

	var projects []Project
    //json非序列化的返回
	err := json.Unmarshal(jsonStr, &projects)
	if err != nil {   //有err就打印err
		return errorHandle.ErrUnmarshalFail
	}
	index := 1   //todo 弄明白了  这是如果web上的zigbee设备的name相同则对应的虚拟设备的alias也相同，这是在后面加上(1、2、3....)以示区分
	// for the love of Gopher DO NOT DO THIS
    //todo 这个for循环还没找到是干嘛用的  ?????
	for _, project := range projects {
		var accessary Accessary
		var accessarysender Accessarysender
		accessary.ProxyID = project.Id
		accessary.Accessory = "Control4"
		commands := accessarysender.Commands
		//这个switch语句用在生成的config.json文件中
		switch label {
		case "Light":
			accessary.Service = "Lightbulb"
		case "Curtain":
			accessary.Service = "WindowCovering"
		default:
			fmt.Println("不存相应设备")

		}
        //这个for循环用在web上的zigbee设备的name如果相同则对应的虚拟设备灯光的alias也相同，这是在后面加上(1、2、3....)以示区分
		for _, projectcommand := range project.Commands {
			if projectcommand.Name == "alias" {
				if Accessaries != nil{
					for _,access := range Accessaries {
						if access.Name != projectcommand.Value{
							accessary.Name = projectcommand.Value
						}else{
							accessary.Name = fmt.Sprintf("%s(%d)",projectcommand.Value,index)
							fmt.Println("accessary.Name: ",accessary.Name)
							index++
							break
						}
					}
				}else{
					accessary.Name = projectcommand.Value
				}
            //如果是可调光的灯光就直接显示这盏灯的值
			}else if projectcommand.Name == "dimmerable"{
				accessary.Dimmerable = projectcommand.Value
			}
           //获取所有的虚拟设备
			var command Commands
			command.ID = projectcommand.Id
			command.Name = projectcommand.Name
			commands = append(commands, command)
		}
		accessarysender.Commands = commands
		accessarysender.Name = project.Name
		accessarysender.ID = project.Id
		accessarysender.Service = label

		Accessaries = append(Accessaries, accessary)
		Accessarysenders = append(Accessarysenders, accessarysender) //store deviceid and commandid
	}
	configdata, err := createConfigData(Accessaries, statusport)
	if err != nil {
		return errorHandle.ErrCreateFail
	}
	b, err := json.MarshalIndent(configdata, "", " ") //变成json字符串
	if err !=nil{
		return errorHandle.ErrMarshalFail
	}
   //生成config.json文件的路径
	err = ioutil.WriteFile("/root/.homebridge/config.json", b, os.ModeAppend) //create config.json
	if err != nil {
		return errorHandle.ErrWriteFail
	}

	return nil
}

func createConfigData(accessaries []Accessary, statusport string) (configdata AutoGenerated, err error) {
	macAddr := common.GetMacAddrByName("eth0")
	mac := strings.ToUpper(macAddr)
	pinstring := strings.Split(mac, ":")
	pinnum := make([]int, 6)
	if len(pinstring) == 6 {
		for i, pin := range pinstring {
			n, err := strconv.ParseUint(pin, 16, 8)
			if err != nil {
				return configdata, errorHandle.ErrParseFail
			} else {
				pinnum[i] = int(n)
			}
		}
	} else {
		err = errorHandle.ErrMacInvalid
		return
	}
	username := fmt.Sprintf("%02X:%02X:%02X:%02X:%02X:%02X", pinnum[5], pinnum[4], pinnum[3], pinnum[2], pinnum[1], pinnum[0])
	Pincode = fmt.Sprintf("%03d-%02d-%03d", pinnum[5]%90+10, pinnum[4]%90+10, pinnum[3]+100)
	sernum := fmt.Sprintf("%02d.%02d.%02d.%02d", pinnum[3]%100, pinnum[2]%100, pinnum[1]%100, pinnum[0]%100)
    //下方就是config.json文件的具体data了
	configdata = AutoGenerated{
		Description: "This is an inSona plugin configuration file",
		Bridge: BridgeStruct{
			Serialnumber: sernum,
			Pin:          Pincode,
			Port:         51826,
			Name:         "homebridge-0",
			Model:        "homebridge-inSona",
			Manufacturer: "inSona",
			Username:     username,
			Repport:      statusport,
		},
		Platforms: []Platform{
			{
				Accessories: accessaries,
				Name:        "Control4",
				ConfigPath:  "/root/.homebridge/config.json",
				Platform:    "Control4",
			},
		},
	}
	return
}
////utils项目中有获取mac的接口，这个写法有问题
//定义获取mac()地址的函数
/*func mac() (mac string) {
	// 获取本机的MAC地址
	interfaces, err := net.Interfaces()
	if err != nil {
		panic("Poor soul, here is what you got: " + err.Error())
	}
	for _, inter := range interfaces {
		//fmt.Println(inter.Name)
		mac = strings.ToUpper(inter.HardwareAddr.String()) //获取本机MAC地址
		if mac != "" {
			return
		}
	}
	return
}*/

//serialnumber,pin,username create auto
